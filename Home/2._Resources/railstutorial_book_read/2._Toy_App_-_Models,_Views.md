# 2. Toy App - Models, Views
Created Monday 20 December 2021

#### 1. Planning the app
- Create an app called `toy-app-rails` using the same steps as in the [previous ](obsidian://open?vault=ruby-on-rails&file=Home%2F2._Resources%2Frailstutorial_book_read%2F1._From_Zero_to_deploy) chapter.
- This app is a Twitter clone, well kind of. It has two datum:
	- **Users** (id: integers, email: string, name: string)
	- **MicroPosts** (id: integer, content: text, user_id: integer). We're using `text` instead of `string` (255 chars) for flexibility in content size, if a change is needed later.
	- Each post is associated with a author(user). i.e. `user_id` of micropost is the author's `id`.
- Generate `Users` Model using [scaffold](obsidian://open?vault=rubyon-rails&file=3.%20Scaffolding) generator

#### 2. The Users Resource
* Bundler: it's a gem file installer. Config is at /Gemfile.
* `rails s` starts the local server.
* MVC basics. 
	* Browser request goes to router, router decides controller (and controller action) based on **URI**.
	* Controller action calls Model functions and stores data as it's instance variables.
	* Model has code to interact with the database. This code is provided by Rails, and doesn't need to be touched, generally.
	* View can access all controller instance variables. Uses ERB templates to template stuff.

#### 3. MVC in action
* A detailed walkthrough of what happens in a HTTP request-response cycle.
* In this case with the `Users` resource.

![](Pasted%20image%2020211220102516.png)

*  Also, an important note from the author: Some references indicate that the view returns the HTML directly to the browser (via a webserver such as Apache or Nginx). Regardless of the implementation details, I find it helpful to think of the controller as a central hub through which all the applicationâ€™s information flows.
* REST architecture and default (named) actions for a controller (`UserController` here).

![](Pasted%20image%2020211220104700.png)

* A controller has some closely related functions (generally 7), named as above. These are called controller '**actions**' 4 of them generate views, the other 3 don't generate views (they're done after DB operations).
* A controller called `ApplicationController` inherits from the `ActiveController::Base`. All other models inherit from the `ApplicationController`. Examples:
```ruby
class ApplicationController < ActionController :: Base
	
end

class UserController < ApplicationController
	
end

class ItemController < ApplicationController
	
end
```

* The `ApplicationRecord` class inherits from `ActiveRecord::Base` class. All other model inherit from the `ApplicationRecord` class. This is the same as how controllers inherit from classes provided by Rails.

#### 4. Weaknesses of this `Users` Resource
* No data validations - I could create users without specifying email or name or both. Not good.
* No authentication - there's no security. Anyone can access any user, and modify it. CIA triad (Confidentiality is non-existent).
* No styles - looks bland.
* No tests - well, the scaffold has *some* tests, but doesn't have place for custom tests, or authentication.
* **No real understanding/learning** - scaffolding is awesome, but it's very bad for learning something.


#### 5. The `MicroPosts` Resource
* Generate a scaffold using `rails generate scaffold Micropost content:text user_id:integer`, and run `rails db:migrate` to create a table.
* After creating a micropost, a green message appears. It is a `p` tag with an `id` of 'notice'. This is called a Flash in Rails, it's a one time message from the server.
* Validating models. Validation of data (models) can be done in model files. Example, to set maximum limit of 140 chars for a MicroPost, a validation can be added in `app/models/MicroPosts.rb` file, like so:

```ruby
class MicroPosts < ApplicationRecord
	validates :content, length: {maximum: 140} # content field maximum length
end
```

This will create an error when the user clicks 'Create Post', if more than 140 chars have been entered. Basically, a **write** to the DB is not allowed.
* Associations: An instance of a model could be related to many instances of other model. *This is simplied as 'a mode is related to other model', for brevity.* 
	* Example: In this app, there are two tables - microposts and users. A user may have many microposts. Also each micropost is also related to one user. 
	* Here, the relation is bi-directional, but it's not always the case.
	* To specify this "association", changes are made to the model (i.e. model class), like so:

	```ruby
	class User < ApplicationRecord
		has_many :microposts
	end

	class MicroPost < ApplicationRecord
		belongs_to :user
		# omitted the validations code, as it's irrelevant
	end
	```
	
	Result: A foreign key is placed in both tables.
###### Using associations
Associations make it very easy to access related info from model objects. Like so:
```ruby
# in controller
@user = User.first;
@posts = @user.microposts # access all microposts for a user

@firstpost = @posts.first # first users first mpost

@mpost = Micropost.first;
@author = @mpost.user; # first microposts author
```
	